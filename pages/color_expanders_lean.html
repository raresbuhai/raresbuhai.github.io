<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Lean formalization notes for Finding Colorings in One-Sided Expanders">
    <title>Lean Formalization — Finding Colorings in One-Sided Expanders</title>

    <link rel="icon" type="image/x-icon" href="../images/favicon.png">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Questrial&display=swap">
    <link rel="stylesheet" type="text/css" href="../style.css">
  </head>
  <body>
    <main class="site-content">
      <section class="content-section">
        <p style="margin: 0 0 12px 0;"><a href="../index.html">← Back to home</a></p>
        <h1>Lean Formalization: Finding Colorings in One-Sided Expanders</h1>
        <p>I formalized in <a href=https://lean-lang.org/>Lean</a> the proofs of the results in Section 4 of our paper <a href="https://arxiv.org/abs/2508.02825">Finding Colorings in One-Sided Expanders</a>; namely, Theorem 4.1 and Corollary 4.2.</p>

        <p>The Lean code was generated using ChatGPT Pro 5.1 and GPT-5.1-Codex-Max. It took ~3 days to arrive at the final result.</p>

        <p><a href="https://github.com/raresbuhai/coloringexpanders-lean">See the repository with the Lean proof here</a>.

        <p>As for the other results in the paper, they are mostly of an algorithmic nature, and as of November 2025 there does not appear to exist enough support in the Lean libraries to make their formalization feasible.</p>
      </section>

      <section class="content-section">
        <h2>Code overview</h2>

        <p>The main file is <code>Colorexpanders.lean</code>. Theorem 4.1 corresponds to theorem <code>large_bottom_rank_implies_large_top_rank</code> and Corollary 4.2 corresponds to theorem <code>small_top_rank_implies_small_bottom_rank</code>.</p>

        <p>The statement of Theorem 4.1 is formalized as follows:</p>
        <pre><code>
theorem large_bottom_rank_implies_large_top_rank
    [Nonempty n] (A : Matrix n n ℝ)
    (hHerm : A.IsHermitian)
    (hNonneg : ∀ i j, 0 ≤ A i j)
    (hOp : ‖A‖ ≤ (1 : ℝ))
    {μ : ℝ} (hμ : 0 ≤ μ)
    {t : ℕ} (hBottom : bottomThresholdRank A hHerm μ ≥ t)
    {σ : ℝ} (hσ₀ : 0 < σ) (hσ₁ : σ < 1) :
    (topThresholdRank A hHerm ((μ^(2:ℕ) - σ) / (1 - σ)) : ℝ)
      ≥ σ^2 * (t : ℝ)
        </code></pre>
        <p>In words, this says that given a real-valued Hermitian matrix <code>A</code> with non-negative entries and operator norm bounded by <code>1</code>, if the number of eigenvalues of <code>A</code> smaller than or equal to <code>μ</code> is at least <code>t</code>, then for any <code>0 < σ < 1</code> we have that the number of eigenvalues of <code>A</code> larger than <code>(μ^2 - σ) / (1 - σ)</code> is at least <code>σ^2 * t</code>.</p>

        <p>The statement uses the custom definitions <code>topThresholdRank</code> and <code>bottomThresholdRank</code>, which are:</p>
        <pre><code>
noncomputable def topThresholdRank
    (A : Matrix n n ℝ) (hA : A.IsHermitian) (τ : ℝ) : ℕ :=
  Fintype.card { i : n // τ ≤ hA.eigenvalues i }

noncomputable def bottomThresholdRank
    (A : Matrix n n ℝ) (hA : A.IsHermitian) (μ : ℝ) : ℕ :=
  Fintype.card { i : n // hA.eigenvalues i ≤ -μ }
        </code></pre>

        <p>Then we see that, informally, the expression <code>topThresholdRank A hHerm τ</code> is defined as the cardinality of the set of eigenvalues of <code>A</code> with value at least <code>τ</code>, and similarly for <code>bottomThresholdRank</code>.</p>
      </section>
    </main>
  </body>
</html>
